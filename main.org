#+STARTUP: inlineimages

#+BEGIN_SRC emacs-lisp :results none :noexport :tangle no
(add-hook 'after-save-hook 'org-babel-tangle 'append)
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
; (add-hook 'evil-insert-state-exit-hook 'org-ctrl-c-ctrl-c)
#+END_SRC

* Библиотеки
- numpy
- matplotlib
- pandas
- scikit-learn

* Исходный код
** py block test
#+BEGIN_SRC python :python "python3" :results file :tangle no
import pandas as pd
import numpy as np
import matplotlib as mp
import matplotlib.pyplot as plt

fig=plt.figure(figsize=(4,2))
x=np.linspace(-15,15)

plt.plot(np.cos(x)/x)
fig.tight_layout()

fn = 'img/plot.png'
plt.savefig(fn)
return fn              # return filename to org-mode
#+END_SRC

#+RESULTS:
[[file:img/plot.png]]

** ipy block test 1 (plot soundwave)
#+BEGIN_SRC ipython :results raw drawer :exports both :tangle no
import scipy
import scipy.fftpack
import pylab
from scipy import pi

plt.rcParams['figure.facecolor'] = 'white'

t = scipy.linspace(0,120,100)
# acc = lambda t: 10*scipy.sin(2*pi*2.0*t) + 5*scipy.sin(2*pi*8.0*t) + 2*scipy.random.random(len(t))
acc = lambda t: 10*scipy.sin(2*t) + 5*scipy.sin(4*t)

signal = acc(t)

FFT = abs(scipy.fft(signal))
freqs = scipy.fftpack.fftfreq(signal.size, t[1]-t[0])

pylab.subplot(211)
pylab.plot(t, signal)

pylab.subplot(212)
pylab.plot(freqs, 20*scipy.log10(FFT),'x')

pylab.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[33]:
[[file:./obipy-resources/7239hbF.png]]
:END:
** ipy block test 2 (fft)
#+BEGIN_SRC ipython :results raw drawer :tangle no
%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
import scipy.fftpack

# Number of samplepoints
N = 600
# sample spacing
T = 1.0 / 800.0
x = np.linspace(0.0, N*T, N)
y = np.sin(50.0 * 2.0*np.pi*x) + 0.5*np.sin(80.0 * 2.0*np.pi*x)
yf = scipy.fftpack.fft(y)
xf = np.linspace(0.0, 1.0/(2.0*T), int(N/2.0))

fig, ax = plt.subplots()
ax.plot(xf, 2.0/N * np.abs(yf[:N//2]))
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[32]:
[[file:./obipy-resources/7239vR2.png]]
** play sound
#+BEGIN_SRC ipython :results raw drawer :tangle no
import sounddevice as sd
import numpy as np

def play_note(freq, duration = 3, rate = 44100):
    freq = float(freq)
    wave = 0.7 * np.sin(2*np.pi*freq * np.linspace(0, duration, rate * duration))
    wave = (32768 * wave).astype(np.int16)
    sd.play(wave, rate)
    sd.wait()

play_note(440.0)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[20]:
:END:

** streams
#+BEGIN_SRC ipython :results raw drawer :tangle no
import sounddevice as sd
import numpy as np
import time

sd.default.clip_off = True
sd.default.never_drop_input = True

def rec_play_callback(indata, outdata, frames, time, status):
    if status:
        print(status)
    outdata[:] = indata

with sd.Stream(channels=2, callback=rec_play_callback):
    while not input().startswith('q'):
        pass

def rec_callback(indata, frames, time, status):
    if status:
        print(status)
    outdata[:] = indata

with sd.InputStream(channels=2, callback=rec_callback):
    while not input().startswith('q'):
        pass
#+END_SRC
** record and plot recording
#+BEGIN_SRC ipython :results raw drawer :tangle no
# Python 3.5 required

import matplotlib.pyplot as plt
import sounddevice as sd
import numpy as np
import time
import queue
import asyncio
import sys

# sd.default.clip_off = True
# sd.default.never_drop_input = True

data_queue = queue.Queue()

def plot_recording_callback(indata, frames, ts, status):
    global data_queue
    val = indata.mean(0)
    data_queue.put(tuple(zip(2*[ts.outputBufferDacTime], val)))
    # print(indata.mean(), frames, time.outputBufferDacTime)
    if status:
        print(status)

loop = asyncio.get_event_loop()

# plt.ion()
plt.axis([0, 10, -1, 1])
# plt.show()

# Set up input loop: wait for 'q'
# quit = False
# @asyncio.coroutine
# def wait_quit():
#     for l in sys.stdin:
#         if l == 'q\n':
#             quit = True
#             return

with sd.InputStream(channels=2, callback=plot_recording_callback):
    # loop.run_until_complete(wait_quit())
    # while not quit:
    try:
        while True:
            pass
        # while True:
        #     try:
        #         data = data_queue.get_nowait()
        #     except queue.Empty:
        #         continue
        #     print(data)
        #     plt.plot(*data[0], 'g-')
        #     # plt.plot(data[1], 'b-')
    except KeyboardInterrupt:
        pass

l = []
while not data_queue.empty():
    l.append(data_queue.get())

for data in l:
    print(*data[0])
    plt.plot(*data[0], 'k-')

# plt.draw()
plt.show()

class tape_plotter(object):
    """
    The SWHear class is made to provide access to continuously recorded
    (and mathematically processed) microphone data.
    """

    def __init__(self,device=None,startStreaming=True):
        """fire up the SWHear class."""
        print(" -- initializing SWHear")

        self.chunk = 4096 # number of data points to read at a time
        self.rate = 44100 # time resolution of the recording device (Hz)

        self.tapeLength = 2 #seconds
        # for tape recording (continuous "tape" of recent audio)
        self.tape=np.empty(self.rate*self.tapeLength)*np.nan

        self.p=pyaudio.PyAudio() # start the PyAudio class
        if startStreaming:
            self.stream_start()

    ### LOWEST LEVEL AUDIO ACCESS
    # pure access to microphone and stream operations
    # keep math, plotting, FFT, etc out of here.

    def stream_read(self):
        """return values for a single chunk"""
        data = np.fromstring(self.stream.read(self.chunk),dtype=np.int16)
        #print(data)
        return data

    def stream_start(self):
        """connect to the audio device and start a stream"""
        print(" -- stream started")
        self.stream=self.p.open(format=pyaudio.paInt16,channels=1,
                                rate=self.rate,input=True,
                                frames_per_buffer=self.chunk)

    def stream_stop(self):
        """close the stream but keep the PyAudio instance alive."""
        if 'stream' in locals():
            self.stream.stop_stream()
            self.stream.close()
        print(" -- stream CLOSED")

    def close(self):
        """gently detach from things."""
        self.stream_stop()
        self.p.terminate()

    ### TAPE METHODS
    # tape is like a circular magnetic ribbon of tape that's continously
    # recorded and recorded over in a loop. self.tape contains this data.
    # the newest data is always at the end. Don't modify data on the type,
    # but rather do math on it (like FFT) as you read from it.

    def tape_add(self):
        """add a single chunk to the tape."""
        self.tape[:-self.chunk]=self.tape[self.chunk:]
        self.tape[-self.chunk:]=self.stream_read()

    def tape_flush(self):
        """completely fill tape with new data."""
        readsInTape=int(self.rate*self.tapeLength/self.chunk)
        print(" -- flushing %d s tape with %dx%.2f ms reads"%\
                  (self.tapeLength,readsInTape,self.chunk/self.rate))
        for i in range(readsInTape):
            self.tape_add()

    def tape_forever(self,plotSec=.25):
        t1=0
        try:
            while True:
                self.tape_add()
                if (time.time()-t1)>plotSec:
                    t1=time.time()
                    self.tape_plot()
        except:
            print(" ~~ exception (keyboard?)")
            return

    def tape_plot(self,saveAs="03.png"):
        """plot what's in the tape."""
        pylab.plot(np.arange(len(self.tape))/self.rate,self.tape)
        pylab.axis([0,self.tapeLength,-2**16/2,2**16/2])
        if saveAs:
            t1=time.time()
            pylab.savefig(saveAs,dpi=50)
            print("plotting saving took %.02f ms"%((time.time()-t1)*1000))
        else:
            pylab.show()
            print() #good for IPython
        pylab.close('all')

class tape_plotter(object):

    def __init__(self, device=None, samplerate=44100, blocksize=128, length=10):
        self.samplerate = samplerate
        self.channels = 1
        self.device = device
        self.blocksize = blocksize # Number of frames passed to callback
        self.tape_duration = length # seconds

        self.tape = np.empty(self.samplerate * self.tape_duration)*np.nan

    def plot_callback(self, indata, frames, timestamp, status):
        print(frames.mean(0), timestamp)

    def tape_add(self, block):
        self.tape[:-self.blocksize] = self.tape[self.blocksize:]
        self.tape[-self.blocksize:] = self.block

    def plot(self):
       with sd.Stream(
               samplerate = self.samplerate,
               blocksize  = self.blocksize,
               channels   = 2,
               dtype      = np.float32,
               device     = self.device,
               callback   = self.plot_callback
       ):
           pass
#+END_SRC
** Tape plotter
#+BEGIN_SRC ipython :results raw drawer :tangle main.py
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import sounddevice as sd
import numpy as np

class tape_plotter(object):
    """
    Plot microphone output as it is recorded
    """

    def __init__(self, device=None, samplerate=44100, length=10, fps=60):
        self.samplerate = samplerate
        self.channels = 1
        self.device = device
        self.tape_duration = length # seconds
        self.fps = fps

        stream_flush_interval = 1.0/self.fps
        self.blocksize = int(samplerate * stream_flush_interval) # Number of frames passed to callbacko

        # No need to plot all the data: select only nth measurements
        self.skip_frames = 50 # Every number of frames minus one skipped for plotting
        self.plot_blocksize = int(self.blocksize / self.skip_frames)

        plot_blocks_num = int(self.samplerate * self.tape_duration / self.skip_frames)
        self.tape = np.empty(plot_blocks_num)*np.nan
        self.time_axis = np.linspace(0, self.tape_duration, plot_blocks_num)

        self.fig, self.ax = plt.subplots()
        self.ax.set_xlim(0, self.tape_duration)
        self.ax.set_ylim(-1.5, 1.5)
        self.plot_line, = plt.plot([], [], 'b-', animated=True)

    def get_stream_callback(self):
        def callback(indata, frames, timestamp, status):
            plot_blocks = indata[::self.skip_frames,0][:self.plot_blocksize]
            self.tape_add(plot_blocks)
        return callback

    def tape_add(self, block):
        self.tape[:-self.plot_blocksize] = self.tape[self.plot_blocksize:]
        self.tape[-self.plot_blocksize:] = block

    def get_update_callback(self):
        def callback(frame):
            self.plot_line.set_data(self.time_axis, self.tape)
            return self.plot_line,
        return callback

    def plot(self):
       with sd.InputStream(
               samplerate = self.samplerate,
               blocksize  = self.blocksize,
               channels   = self.channels,
               dtype      = np.float32,
               device     = self.device,
               callback   = self.get_stream_callback(),
       ):
           ani = FuncAnimation(
               self.fig, self.get_update_callback(),
               interval = int(1/self.fps), # ~ 60 FPS
               blit = True
           )
           plt.show(block=True)

tp = tape_plotter(length=10, fps=60)
tp.plot()
#+END_SRC
#+END_SRC
